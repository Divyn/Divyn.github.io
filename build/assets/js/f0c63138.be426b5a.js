"use strict";(self.webpackChunkdivyasshree_portfolio=self.webpackChunkdivyasshree_portfolio||[]).push([[7143],{2421:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"Personal Blog/Kubernetes/StorageClasses","title":"Storage Classes","description":"Volumes are used by pods to store data.","source":"@site/docs/Personal Blog/Kubernetes/StorageClasses.md","sourceDirName":"Personal Blog/Kubernetes","slug":"/Personal Blog/Kubernetes/StorageClasses","permalink":"/divyn.github.io/docs/Personal Blog/Kubernetes/StorageClasses","draft":false,"unlisted":false,"editUrl":"https://github.com/divyn/divyn.github.io/edit/main/docs/Personal Blog/Kubernetes/StorageClasses.md","tags":[],"version":"current","frontMatter":{"layout":"default","title":"Storage Classes","parent":"Kubernetes"},"sidebar":"tutorialSidebar","previous":{"title":"Deployment and StatefulSet","permalink":"/divyn.github.io/docs/Personal Blog/Kubernetes/StatefulSets"},"next":{"title":"Taints and Tolerations","permalink":"/divyn.github.io/docs/Personal Blog/Kubernetes/Taints&Tolerations"}}');var o=t(4848),r=t(8453);const a={layout:"default",title:"Storage Classes",parent:"Kubernetes"},i="Volume",l={},d=[];function u(e){const s={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.header,{children:(0,o.jsx)(s.h1,{id:"volume",children:"Volume"})}),"\n",(0,o.jsx)(s.p,{children:"Volumes are used by pods to store data."}),"\n",(0,o.jsx)(s.h1,{id:"pv",children:"PV"}),"\n",(0,o.jsx)(s.p,{children:'"Persistent" -> the method used to store data is such that it continues beyond the lifetime of a pod as well.\nA Persistent Volume is a storage unit available cluster-wide whose lifecycle independant of a single pod.'}),"\n",(0,o.jsx)(s.h1,{id:"pvc",children:"PVC"}),"\n",(0,o.jsx)(s.p,{children:"PersistentVolumeClaim (PVC) is a request for storage by a user. It is similar to a pod. Pods consume node resources and PVCs consume PV resources."}),"\n",(0,o.jsx)(s.h1,{id:"dynamic-provisioning-of-volumes",children:"Dynamic provisioning of volumes"}),"\n",(0,o.jsx)(s.p,{children:"By enabling dynamic provisioning of volumes, storage gets provisioned automatically when the application requires it,\nTo enable dynamic provisioning, a cluster administrator needs to pre-create one or more StorageClass objects for users. StorageClass objects define which provisioner should be used and what parameters should be passed to that provisioner when dynamic provisioning is invoked. The name of a StorageClass object must be a valid DNS subdomain name."}),"\n",(0,o.jsx)(s.pre,{children:(0,o.jsx)(s.code,{children:"apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: claim1\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: fast\n  resources:\n    requests:\n      storage: 30Gi\n\n"})})]})}function c(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>i});var n=t(6540);const o={},r=n.createContext(o);function a(e){const s=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);